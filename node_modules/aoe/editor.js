/**
 * Created by exolution on 17/6/19.
 */
class EventEmitter{
    constructor() {
        this._handlers = {};
    }
    off(method, handler) {
        if (handler) {
            for (var i = 0; i < this._handlers[method].length; i++) {
                if (this._handlers[method][i] === handler) {
                    this._handlers[method].splice(i, 1);
                    i--;
                }
            }
        }
        else {
            this._handlers[method] = [];
        }
    }

    once(method, handler) {
        var self = this;
        var fired = false;

        function g() {
            self.off(method, g);
            if (!fired) {
                fired = true;
                handler.apply(self, Array.prototype.slice.call(arguments));
            }
        }

        this.on(method, g);
    }

    on(method, handler) {
        if (this._handlers[method]) {
            this._handlers[method].push(handler);
        }
        else {
            this._handlers[method] = [handler];
        }
    }

    _emit(method, args, context) {
        var handlers = this._handlers[method];
        if (handlers && handlers.length > 0) {
            handlers.forEach(function (handler) {
                handler.apply(context, args)
            });
            return true;
        }
        else {
            return false;
        }
    }

    emit(method) {
        var context = {};
        var args = Array.prototype.slice.call(arguments, 1);
        if (!this._emit(method, args, context)) {
            this._emit('*', args, context)
        }
        this._emit('$finally', args, context);
        return context;
    }
}
class Shape extends EventEmitter{
    constructor() {
        super()
        this.completed = false
        this.init()
    }

    init() {

    }
}
class Polygon extends Shape {
    constructor() {
        super()
        this.vertexes = []
        this.vertexWidth = 11
        this.vertexHeight = 11
        this.path = new Path2D()
        this.curSelectVertexIndex = -1
        this.vertexMoved=false
    }
    serialize(){
        return {type:'polygon',data:this.vertexes.map(v=>v.x+','+v.y).join(',').split(',')}
    }
    addVertex(x, y) {
        this.vertexes.push({x, y})
        if(this.vertexes.length>3&&!this.vertexMoved) {
            this.vertexes.sort((a, b)=>a.x - b.x || a.y - b.y)

            let last = this.vertexes.length - 1
            let a = (this.vertexes[0].y - this.vertexes[last].y) / (this.vertexes[0].x - this.vertexes[last].x)
            let b = this.vertexes[last].y - a * this.vertexes[last].x
            let up = [this.vertexes[0]], down = []
            for (let i = 1; i < this.vertexes.length - 1; i++) {
                let v = this.vertexes[i]
                if (a * v.x + b <= v.y) {
                    up.push(v)
                }
                else {
                    down.unshift(v)
                }
            }
            down.unshift(this.vertexes[last])
            this.curSelectVertexIndex = -1
            this.vertexes = up.concat(down)
        }
    }

    init() {
        this.on('mousedown', (data)=> {
            if (data.keyStatus.shift || this.vertexes.length < 3) {
                this.addVertex(data.x, data.y)
                if (this.vertexes.length > 2) {
                    this.completed = true
                    this.selected = true
                }
            }
        })
        this.on('keyChange',(data)=>{
            if(data.key=='backspace'&&data.keyStatus.backspace===false&&data.keyStatus.alt){
                if(this.curSelectVertexIndex!=-1){
                    this.vertexes.splice(this.curSelectVertexIndex,1)
                    this.curSelectVertexIndex=-1
                    if(this.vertexes.length<3){
                        this.completed=false
                    }
                }
            }
        })
    }

    displayVertex() {
        this._displayVertex = true
    }

    hideVertex() {
        this._displayVertex = false
    }

    get vertexSelected() {
        return this.curSelectVertexIndex >= 0
    }

    select(x, y, ctx) {
        if (ctx.isPointInPath(this.path, x, y)) {
            this.selected = true

            return true
        }
        return false
    }

    clearSelect() {
        this.selected = false
    }

    selectVertex(x, y) {
        this.curSelectVertexIndex = -1
        for (let i = 0; i < this.vertexes.length; i++) {
            let vertex = this.vertexes[i]
            if (Math.abs(vertex.x - x) <= (this.vertexWidth - 1) / 2 && Math.abs(vertex.y - y) <= (this.vertexHeight - 1) / 2) {
                this.curSelectVertexIndex = i
                return vertex
            }
        }
        return false
    }

    clearVertexSelect() {
        this.curSelectVertexIndex = -1
    }

    translate(x, y, all) {
        if (this.curSelectVertexIndex >= 0 && !all) {
            this.vertexes[this.curSelectVertexIndex].x += x
            this.vertexes[this.curSelectVertexIndex].y += y
            this.vertexMoved=true
        }
        else {
            this.vertexes.forEach((v) => {
                v.x += x
                v.y += y
            })
        }

    }

    removeVertex() {
        if (this.curSelectVertexIndex >= 0)
            this.vertexes.splice(this.curSelectVertexIndex, 1)
    }

    render(ctx) {
        if (this.vertexes.length > 1) {
            this.path = new Path2D()

            for (let i = 0; i < this.vertexes.length; i++) {
                if (i == 0) {
                    this.path.moveTo( this.vertexes[0].x,  this.vertexes[0].y)
                }
                else {
                    this.path.lineTo( this.vertexes[i].x,  this.vertexes[i].y)
                }
                if (this._displayVertex) {
                    if (i === this.curSelectVertexIndex) {
                        ctx.fillStyle = 'red'
                    }

                    ctx.fillRect( this.vertexes[i].x - (this.vertexWidth - 1) / 2,  this.vertexes[i].y - (this.vertexHeight - 1) / 2, this.vertexWidth - 1, this.vertexHeight - 1)
                    if (i === this.curSelectVertexIndex) {
                        ctx.fillStyle = 'black'
                    }
                }

            }
            this.path.closePath()

            if (this.selected) {
                ctx.save()
                ctx.strokeStyle = '#0a70f5'

            }
            ctx.stroke(this.path)
            if (this.selected) {
                ctx.restore()
            }


        }
        else if(this.vertexes.length == 1){
            ctx.fillRect(this.vertexes[0].x - (this.vertexWidth - 1) / 2, this.vertexes[0].y - (this.vertexHeight - 1) / 2, this.vertexWidth - 1, this.vertexHeight - 1)
        }
    }
}
class Rectangle extends Polygon {
    constructor() {
        super()
        this.sortVertex=false
    }

    setVertex(x, y) {
        if (!this.vertexes[0]) {
            this.vertexes[0] = {x, y}
            return
        }
        else {
            this.vertexes[2] = {x, y}
        }
        this.vertexes[3] = {x: this.vertexes[0].x, y: this.vertexes[2].y}
        this.vertexes[1] = {x: this.vertexes[2].x, y: this.vertexes[0].y}

    }
    serialize(){
        let rect=this.rect()
        return {type:'rectangle',data:rect}
    }
    init() {
        this.on('mousedown', (data)=> {
            if (data.keyStatus.empty()) {
                this.setVertex(data.x, data.y)
                if(this.vertexes.length>=4) {
                    this.completed = true
                }
            }
            let onDrag = (data)=> {
                this.setVertex(data.x, data.y)
            }
            this.on('drag', onDrag)
            this.once('mouseup', ()=> {
                this.clearVertexSelect()
                this.off('drag',onDrag)
                if(this.vertexes.length>=4) {
                    this.completed = true
                }
            })
        })

    }

    centerPoint() {
        return {x: (this.vertexes[1].x - this.vertexes[0].x) / 2, y: (this.vertexes[3].y - this.vertexes[0].y) / 2}
    }

    rect() {
        let vertexes=this.vertexes.concat().sort((a,b)=>a.x-b.x||a.y-b.y)
        return [vertexes[0].x, vertexes[0].y, Math.abs(vertexes[2].x -vertexes[0].x), Math.abs(vertexes[1].y - vertexes[0].y)]
    }

    translate(distX, distY, all) {
        if (this.curSelectVertexIndex != -1 && !all) {
            //这块逻辑是不是很费解 哈哈哈
            //费解就对了
            //由当前顶点的索引推算出他相邻顶点的索引 矩形顶点的索引如下
            //0 1  2 3
            //3 2  1 0
            let Xrelate = (this.curSelectVertexIndex + (this.curSelectVertexIndex % 2 == 0 ? 3 : 1)) % 4
            let Yrelate = (this.curSelectVertexIndex + (this.curSelectVertexIndex % 2 == 0 ? 1 : 3)) % 4
            this.vertexes[this.curSelectVertexIndex].x += distX
            this.vertexes[this.curSelectVertexIndex].y += distY
            this.vertexes[Xrelate].x = this.vertexes[this.curSelectVertexIndex].x
            this.vertexes[Yrelate].y = this.vertexes[this.curSelectVertexIndex].y
        }
        else {
            this.vertexes.forEach((v) => {
                v.x += distX
                v.y += distY
            })
        }
    }

    select(x, y) {
        if(this.vertexes.length>=4) {
            let vertexes=this.vertexes.concat().sort((a,b)=>a.x-b.x||a.y-b.y)
            return x > vertexes[0].x && x < vertexes[2].x && y > vertexes[0].y && y < vertexes[1].y
        }
        return false
    }
}
class Ellipse extends Rectangle {
    constructor() {
        super()
    }
    serialize(){
        let rect = this.rect()
        return {type:'ellipse',data:[rect[0] + rect[2] / 2, rect[1] + rect[3] / 2, rect[2] / 2, rect[3] / 2, 0, 0, 2 * Math.PI]}
    }
    select(x, y, ctx) {
        this.path = new Path2D()
        if(this.vertexes.length>=4) {
            let rect = this.rect()
            this.path.ellipse(rect[0] + rect[2] / 2, rect[1] + rect[3] / 2, rect[2] / 2, rect[3] / 2, 0, 0, 2 * Math.PI)
            return ctx.isPointInPath(this.path, x, y)
        }
        return false
    }

    render(ctx) {
        if (this.vertexes.length > 1) {
            this.path = new Path2D()
            ctx.save()
            if (this.selected) {
                ctx.strokeStyle = 'rgba(0,0,0,0.5)'
                for (let i = 0; i < this.vertexes.length; i++) {
                    if (i == 0) {
                        this.path.moveTo(this.vertexes[0].x, this.vertexes[0].y)
                    }
                    else {
                        this.path.lineTo(this.vertexes[i].x, this.vertexes[i].y)
                    }
                    if(this._displayVertex) {
                        ctx.fillStyle = 'black'
                    }
                    else {
                        ctx.fillStyle = 'rgba(0,0,0,0.5)'
                    }
                    ctx.fillRect(this.vertexes[i].x - (this.vertexWidth - 1) / 2, this.vertexes[i].y - (this.vertexHeight - 1) / 2, this.vertexWidth - 1, this.vertexHeight - 1)
                }

            }
            this.path.closePath()
            ctx.stroke(this.path)
            ctx.strokeStyle='black'
            let rect = this.rect()
            ctx.beginPath()
            ctx.ellipse(rect[0] + rect[2] / 2, rect[1] + rect[3] / 2, rect[2]/2, rect[3]/2, 0, 0, 2 * Math.PI)
            ctx.closePath()
            ctx.stroke()

            ctx.restore()


        }
    }
}
class ShapeSet {
    constructor(ctx) {

        this.shapeList = []
        this.ctx = ctx
    }

    render() {
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)
        this.shapeList.forEach((shape)=> {
            shape.render(this.ctx)
        })
    }

    select(x, y, keySet) {
        let flag = false
        if (keySet.empty()) {
            this.shapeList.forEach((shape)=> {
                if (!flag&&shape.select(x, y, this.ctx)) {
                    if (this.selectedShape !== shape && !this.selectedShape.completed) {
                        this.removeShape(this.selectedShape)
                    }
                    this.selectedShape = shape
                    shape.selected = true
                    shape.clearVertexSelect()
                    flag = true
                }
                else {
                    shape.selected = false
                }

            })
        }
        return flag
    }

    selectVertex(x, y) {
        this.shapeList.forEach((shape)=> {
            if (shape.selectVertex(x, y)) {
                if (this.selectedShape !==shape && !this.selectedShape.completed) {
                    this.removeShape(this.selectedShape)
                }
                this.selectedShape = shape
                shape.selected = true
            }
            else {
                shape.clearVertexSelect()
                shape.selected = false
            }

        })
    }

    handle(method, data) {

        if (this.selectedShape && this.selectedShape.emit(method, data)) {
            //this.selectedShape.render(this.ctx)
            this.render()
        }
        if (method == 'keyChange' && data.key == 'alt') {
            this.shapeList.forEach((shape)=> {
                if (data.keyStatus.alt)shape.displayVertex()
                else shape.hideVertex()
            })
            this.render()
        }
        if(method=='keyChange'&&data.key=='backspace'&&data.keyStatus.empty()&&data.keyStatus.backspace==false){
            this.remove(this.selectedShape)
            this.render()
        }
    }
    remove(shape){
        for(let i=0;i<this.shapeList.length;i++){
            if(this.shapeList[i]===shape) {
                this.shapeList.splice(i, 1)
                break
            }
        }
    }
    createShape(ShapeClass) {
        this.selectedShape = new ShapeClass
        this.shapeList.forEach((shape)=> {
            shape.selected = false
        })
        this.shapeList.push(this.selectedShape)
        this.selectedShape.selected = true
    }

    removeShape(shape) {
        for (let i = 0; i < this.shapeList.length; i++) {
            if (this.shapeList[i] === shape) {
                this.shapeList.splice(i, 1)
                break
            }
        }
        this.render()
    }
}

class KeyStatus {
    empty() {
        return !this.shift&&!this.meta&&!this.ctrl&&!this.alt
    }

    only(key) {
        return !Object.keys(this).some(k=>k != key && this[k])
    }
}
class ShapeEditor extends EventEmitter{
    constructor(left, top, width, height) {
        super()
        let $canvas
        if (arguments.length == 1 && left instanceof Node) {

            let target = left

            if(target.tagName=='CANVAS'){
                $canvas=target

            }
            else{
                let {left,top,width,height}=target.getBoundingClientRect()
            }
        }
        if(!$canvas) {
            let $canvas = document.createElement('canvas')
            $canvas.width = width
            $canvas.height = height
            $canvas.style.position = 'absolute'
            $canvas.style.left = left + 'px'
            $canvas.style.top = top + 'px'
            document.body.appendChild($canvas)
        }
        if($canvas.tabIndex===undefined){
            $canvas.tabIndex=1
        }
        let ctx = $canvas.getContext('2d')

        let baseX, baseY, pureClick
        let shapeSet = new ShapeSet(ctx)
        this.shapeSet = shapeSet
        let keyStatus = new KeyStatus()
        this.curShapeClass = Rectangle
        $canvas.addEventListener('mousedown',  (e)=> {
            baseX = e.offsetX
            baseY = e.offsetY
            if (keyStatus.alt) {
                shapeSet.selectVertex(baseX, baseY, keyStatus)

            }
            else if (!shapeSet.select(baseX, baseY, keyStatus)) {
                if (keyStatus.empty() && (!shapeSet.selectedShape || shapeSet.selectedShape.completed)) {
                    shapeSet.createShape(this.curShapeClass)
                }
                shapeSet.handle('mousedown', {x: baseX, y: baseY, keyStatus})
            }
            else{
                this.emit('shapeSelected',shapeSet.selectedShape)

            }


            $canvas.addEventListener('mousemove', onMouseMove)
            //e.preventDefault()
            //e.stopPropagation()
        })
        function onMouseMove(e) {
            let x = e.offsetX
            let y = e.offsetY
            if (shapeSet.selectedShape.completed||keyStatus.alt&&shapeSet.selectedShape.vertexes.length>1 ) {
                shapeSet.selectedShape.translate(x - baseX, y - baseY)
            }
            else {
                shapeSet.handle('drag', {x, y, distX: x - baseX, distY: y - baseY, keyStatus})
            }
            shapeSet.render()
            baseX = x
            baseY = y
            e.preventDefault()
            e.stopPropagation()
        }

        $canvas.addEventListener('mouseup', function (e) {
            let x = e.offsetX
            let y = e.offsetY
            pureClick = Math.abs(x - baseX) < 6 && Math.abs(y - baseY) < 6
            shapeSet.handle('mouseup', {x, y, pureClick, keyStatus})
            $canvas.removeEventListener('mousemove', onMouseMove)

        })


        document.addEventListener('keydown', function (e) {
            console.log(e)
            if(e.target===$canvas) {
                let keyName = e.key.toLowerCase()
                if (!keyStatus[keyName]) {
                    keyStatus[keyName] = true
                    shapeSet.handle('keyChange', {key: keyName, keyStatus})
                }

            }
        })

        document.addEventListener('keyup', function (e) {
            if(e.target===$canvas) {
                let keyName = e.key.toLowerCase()
                if (keyStatus[keyName]) {
                    keyStatus[keyName] = false
                    shapeSet.handle('keyChange', {key: keyName, keyStatus})
                }
            }
        })
    }
    get selectedShape(){
        return this.shapeSet.selectedShape
    }
    setShapeType(shapeType){
        switch(shapeType){
            case 'Rectangle':
                this.curShapeClass=Rectangle
                break
            case 'Polygon':
                this.curShapeClass=Polygon
                break
            case 'Ellipse':
                this.curShapeClass=Ellipse
                break
            default:
                this.curShapeClass=Rectangle
        }
    }
}