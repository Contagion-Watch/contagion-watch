'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Created by exolution on 17/6/7.
 */
Promise.defer = function () {
    var _defer = {};
    var promise = new Promise(function (resolve, reject) {
        _defer.resolve = resolve;
        _defer.reject = reject;
    });
    promise.resolve = _defer.resolve;
    promise.reject = _defer.reject;
    return promise;
};

var Sprite = function () {
    function Sprite(imgSrc, column, row, width, height) {
        _classCallCheck(this, Sprite);

        this.imgSrc = imgSrc;
        this.imgWidth = width;
        this.imgHeight = height;
        this.row = row;
        this.scale = 1;
        this.column = column;
        this.animation = {};
        this.rect = false;
        this.area = {};
        this.Position = {
            x: 0, y: 0
        };
        Sprite.spritesList.push(this);
    }

    _createClass(Sprite, [{
        key: 'createArea',
        value: function createArea(name, config) {
            this.area[name] = config;
        }
    }, {
        key: 'init',
        value: function init() {
            var _this = this;

            return new Promise(function (resolve, reject) {
                _this.image = new Image();
                _this.image.src = _this.imgSrc;
                _this.image.onload = function () {
                    _this.imgWidth = _this.imgWidth || _this.image.width;
                    _this.imgHeight = _this.imgHeight || _this.image.height;
                    if (Sprite.onProgress) {
                        Sprite.onProgress(++Sprite.complete, Sprite.spritesList.length);
                    }
                    resolve();
                };
            });
        }
    }, {
        key: 'playAnimation',
        value: function playAnimation(name) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                delay = _ref.delay,
                after = _ref.after,
                repeat = _ref.repeat;

            var callback = arguments[2];

            this.curAnimation = {
                promise: Promise.defer(),
                indexs: this.animation[name].indexs,
                curIndex: 0,
                elapse: 0,
                after: after,
                curAfter: after || 0,
                delay: delay,
                repeat: repeat,
                callback: callback,
                count: 0,
                state: 'START',
                name: name,
                fps: this.animation[name].indexs.length / this.animation[name].duration
            };
            return this.curAnimation.promise;
        }
    }, {
        key: 'getArea',
        value: function getArea(name, frmIdx) {
            var def = this.area[name],
                area = void 0;
            frmIdx = this.curAnimation.indexs[this.curAnimation.curIndex];
            for (var key in def) {
                var splits = key.split('-');
                if (frmIdx >= +splits[0] && frmIdx <= +splits[1]) {
                    area = def[key];
                } else if (+splits[0] == frmIdx) {
                    area = def[key];
                    break;
                }
            }
            if (!area) area = this.area['*'];
            if (area) {
                return [this.Position.x - (this.imgWidth / this.column / 2 - area[0]) * this.scale, this.Position.y - (this.imgHeight / this.row / 2 - area[1]) * this.scale, area[2] * this.scale, area[3] * this.scale];
            }
            return null;
        }
    }, {
        key: 'draw',
        value: function draw(animation, ctx) {
            var pos = animation.indexs[animation.curIndex];
            var width = this.imgWidth / this.column;
            var height = this.imgHeight / this.row;
            var targetX = this.Position.x - width / 2 * this.scale;
            var targetY = this.Position.y - height / 2 * this.scale;
            this.bottom = this.Position.y - height / 2 * this.scale + height * this.scale;
            ctx.drawImage(this.image, pos % this.column * width, Math.floor(pos / this.column) * height, width, height, targetX, targetY, width * this.scale, height * this.scale);
            if (this.rect) {
                ctx.beginPath();
                ctx.strokeStyle = "#fff";
                ctx.rect(this.Position.x - width / 2 * this.scale, this.Position.y - height / 2 * this.scale, width * this.scale, height * this.scale);
                for (var key in this.area) {
                    var area = this.getArea(key, pos);
                    if (area) {
                        ctx.rect(area[0], area[1], area[2], area[3]);
                        ctx.font = '30px serif';
                        ctx.fillText(pos + key, area[0] + 2, area[1] + 2);
                    }
                }
                ctx.stroke();
                ctx.closePath();
            }
        }
    }, {
        key: 'createAnimation',
        value: function createAnimation(name, indexs, duration) {
            if (typeof indexs === 'string') {
                indexs = genArray(indexs);
            }
            this.animation[name] = { indexs: indexs, duration: duration };
        }
    }, {
        key: 'stopAnimation',
        value: function stopAnimation(name, immidiate) {
            if (immidiate) {
                this.curAnimation = null;
            } else {
                this.curAnimation.repeat = false;
            }
        }
    }, {
        key: 'render',
        value: function render(ctx, elapse, interval) {

            if (this.curAnimation) {

                this.curAnimation.elapse += interval;
                this.draw(this.curAnimation, ctx);
                if (this.curAnimation.elapse * this.curAnimation.fps > 1) {
                    if (this.curAnimation.curIndex + 1 == this.curAnimation.indexs.length) {

                        if (this.curAnimation.curAfter <= 0) {
                            if (--this.curAnimation.repeat > 0) {
                                this.curAnimation.state = 'START';
                                this.curAnimation.curAfter = this.curAnimation.after || 0;
                                this.curAnimation.curIndex = 0;
                                this.curAnimation.callback && this.curAnimation.callback(this.curAnimation.count++);
                            } else {
                                this.curAnimation.state = 'END';
                                this.curAnimation.promise.resolve();
                                this.curAnimation = null;
                                return;
                            }
                        } else {
                            this.curAnimation.state = 'AFTER';
                        }
                    } else {
                        this.curAnimation.curIndex++;
                    }

                    this.curAnimation.elapse = this.curAnimation.elapse % (1 / this.curAnimation.fps);
                }
                if (this.curAnimation.state == 'AFTER') {
                    this.curAnimation.curAfter -= interval;
                }
            }
        }
    }], [{
        key: 'init',
        value: function init() {
            Sprite.complete = 0;
            return Promise.all(Sprite.spritesList.map(function (sprites) {
                return sprites.init();
            }));
        }
    }]);

    return Sprite;
}();

function genArray(fromTo) {
    var splits = fromTo.split('-');
    var arr = [];
    for (var i = +splits[0]; i <= +splits[1]; i++) {
        arr.push(i);
    }
    return arr;
}
Sprite.spritesList = [];
var glIntervalList = [];

var Interval = function () {
    function Interval(callback, interval, repeat, immidiate) {
        _classCallCheck(this, Interval);

        this.callback = callback;
        this.interval = interval;
        this.repeat = repeat;
        this.immidiate = immidiate;
        this.elapse = 0;
        glIntervalList.push(this);
        this._pause = false;
        if (typeof repeat === 'boolean') {
            this.immidiate = repeat;
            this.repeat = undefined;
        }
        if (this.immidiate) {
            this.callback();
        }
    }

    _createClass(Interval, [{
        key: 'pause',
        value: function pause() {
            this._pause = true;
        }
    }, {
        key: 'resume',
        value: function resume() {
            this._pause = false;
        }
    }, {
        key: 'testOrRun',
        value: function testOrRun(elapse, interval) {
            if (!this._pause) {
                this.elapse += interval;
                if (this.elapse > this.interval) {
                    this.callback();
                    this.elapse = this.elapse & interval;
                    if (!this.repeat && --this.repeat <= 0) {
                        this.stop();
                    }
                }
            }
        }
    }, {
        key: 'stop',
        value: function stop() {
            for (var i = 0; i < glIntervalList.length; i++) {
                if (glIntervalList[i] === this) {
                    glIntervalList.splice(i, 1);
                    break;
                }
            }
        }
    }]);

    return Interval;
}();

var glGameObjectList = [];

var GameObject = function () {
    function GameObject(tag) {
        _classCallCheck(this, GameObject);

        this.tag = tag;
        glGameObjectList.push(this);
    }

    _createClass(GameObject, [{
        key: 'destroy',
        value: function destroy() {
            for (var i = 0; i < glGameObjectList.length; i++) {
                if (glGameObjectList[i] === this) {
                    glGameObjectList.splice(i, 1);
                    break;
                }
            }
        }
    }, {
        key: 'render',
        value: function render(ctx, elapse, interval) {
            if (this.sprite) {
                this.sprite.render(ctx, elapse, interval);
            }
        }
    }, {
        key: 'setInterval',
        value: function setInterval(callback, interval, once) {}
    }, {
        key: 'clearInterval',
        value: function clearInterval(intervalId) {}
    }]);

    return GameObject;
}();

var Cursor = function (_GameObject) {
    _inherits(Cursor, _GameObject);

    function Cursor() {
        _classCallCheck(this, Cursor);

        var _this2 = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, 'cursor'));

        _this2.z = Infinity;
        return _this2;
    }

    _createClass(Cursor, [{
        key: 'render',
        value: function render(ctx, elapse, interval) {
            ctx.beginPath();
            //ctx.fillStyle="#d3d14d"
            ctx.fillStyle = 'rgba(211, 209, 0,0.8)';
            var len = 30,
                w = 6,
                dist = 8;
            ctx.fillRect(this.x - (w - 1) / 2, this.y - (w - 1) / 2, w, w);
            ctx.fillRect(this.x - len - (w - 1) / 2 - dist, this.y - (w - 1) / 2, len, w);
            ctx.fillRect(this.x + dist + (w - 1) / 2, this.y - (w - 1) / 2, len, w);
            ctx.fillRect(this.x - (w - 1) / 2, this.y - (w - 1) / 2 - dist - len, w, len);
            ctx.fillRect(this.x - (w - 1) / 2, this.y + (w - 1) / 2 + dist, w, len);
            ctx.closePath();
            ctx.stroke();
        }
    }]);

    return Cursor;
}(GameObject);

var Actor = function (_GameObject2) {
    _inherits(Actor, _GameObject2);

    function Actor() {
        _classCallCheck(this, Actor);

        var _this3 = _possibleConstructorReturn(this, (Actor.__proto__ || Object.getPrototypeOf(Actor)).call(this, 'actor'));

        _this3.z = Infinity;

        return _this3;
    }

    _createClass(Actor, [{
        key: 'init',
        value: function init(hp, maxShell, scale) {
            this.hp = hp;
            this.maxShell = maxShell;
            this.shell = maxShell;
            this.sprite.playAnimation('idle', { repeat: Infinity });
            this.sprite.scale = scale;
            this.sprite.Position = { x: 160 * scale, y: cvs.height - 160 * scale };
            this.kills = 0;
        }
    }, {
        key: 'stopAttack',
        value: function stopAttack() {
            this._attacking = false;
        }
    }, {
        key: 'attack',
        value: function attack(targetPos, callback) {
            var _this4 = this;

            if (!this.sprite.curAnimation || this.sprite.curAnimation.name !== 'change') {
                this._attacking = true;
                var aniName = void 0;
                this.targetPos = targetPos;
                if (targetPos.x / cvs.width < 1 / 3) {
                    aniName = 'left';
                } else if (targetPos.x / cvs.width < 2 / 3) {
                    aniName = 'middle';
                } else {
                    aniName = 'right';
                }
                this.shell--;
                this.onShellChange && this.onShellChange();
                cvs.style.animation = "shake ease 0.32s infinite";
                this.sprite.playAnimation(aniName, { repeat: 2 }).then(function () {
                    cvs.style.animation = '';
                    if (_this4.shell > 0) {
                        if (_this4._attacking) {
                            _this4.attack(_this4.targetPos, callback);
                        } else {
                            _this4.sprite.playAnimation('idle', { repeat: Infinity });
                        }
                    } else {
                        _this4.sprite.playAnimation('change').then(function () {
                            _this4.shell = _this4.maxShell;
                            _this4.onShellChange && _this4.onShellChange();
                            if (_this4._attacking) {
                                _this4.attack(_this4.targetPos, callback);
                            } else {
                                _this4.sprite.playAnimation('idle', { repeat: Infinity });
                            }
                        });
                    }
                });
                var ret = glGameObjectList.filter(function (go) {
                    return go.tag == 'enemy';
                }).sort(function (a, b) {
                    return b.sprite.scale - a.sprite.scale;
                }).some(function (go) {
                    var head = go.sprite.getArea('head');
                    if (head && isPointInArea(targetPos.x, targetPos.y, head)) {
                        callback.call(_this4, 'head', go);
                        return true;
                    } else {
                        var shield = go.sprite.getArea('shield');
                        if (shield && isPointInArea(targetPos.x, targetPos.y, shield)) {
                            callback.call(_this4, 'shield', go);
                            return true;
                        }
                        var body = go.sprite.getArea('body');
                        if (body && isPointInArea(targetPos.x, targetPos.y, body)) {
                            callback.call(_this4, 'body', go);
                            return true;
                        }
                    }
                });
                if (!ret) {
                    callback();
                }
            }
        }
    }, {
        key: 'render',
        value: function render(ctx, elapse, interval) {
            this.sprite.render(ctx, elapse, interval);
        }
    }]);

    return Actor;
}(GameObject);

function isPointInArea(x, y, area) {
    return x > area[0] && y > area[1] && x < area[0] + area[2] && y < area[1] + area[3];
}

var Effect = function (_GameObject3) {
    _inherits(Effect, _GameObject3);

    function Effect(sprite, pos, scale) {
        _classCallCheck(this, Effect);

        var _this5 = _possibleConstructorReturn(this, (Effect.__proto__ || Object.getPrototypeOf(Effect)).call(this, 'effect'));

        _this5.sprite = {};
        Object.setPrototypeOf(_this5.sprite, sprite);
        _this5.sprite.Position = pos;
        _this5.sprite.scale = scale || 1;
        _this5.z = Infinity;
        _this5.sprite.playAnimation('effect').then(function () {
            _this5.destroy();
        });
        return _this5;
    }

    return Effect;
}(GameObject);

var Text = function (_GameObject4) {
    _inherits(Text, _GameObject4);

    function Text(text, x, y, speed, duration) {
        _classCallCheck(this, Text);

        var _this6 = _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, 'text'));

        _this6.z = Infinity;
        _this6.text = text;
        _this6.x = x;
        _this6.y = y;
        _this6.elapse = 0;
        _this6.speed = speed;
        _this6.duration = duration;
        return _this6;
    }

    _createClass(Text, [{
        key: 'render',
        value: function render(ctx, elapse, interval) {

            ctx.font = '48px serif';
            ctx.fillText(this.text, this.x, this.y);
            this.elapse += interval;
            if (this.elapse < this.duration) {
                this.y -= interval * this.speed;
            } else {
                this.destroy();
            }
        }
    }]);

    return Text;
}(GameObject);

var Enemy = function (_GameObject5) {
    _inherits(Enemy, _GameObject5);

    function Enemy() {
        _classCallCheck(this, Enemy);

        var _this7 = _possibleConstructorReturn(this, (Enemy.__proto__ || Object.getPrototypeOf(Enemy)).call(this, 'enemy'));

        _this7.z = 1;
        _this7.life = 2;
        return _this7;
    }

    _createClass(Enemy, [{
        key: 'setSprite',
        value: function setSprite(sprite) {
            this.sprite = {};
            Object.setPrototypeOf(this.sprite, sprite);
        }
    }, {
        key: 'init',
        value: function init(initialScale, destScale, speed, x, y) {
            this.sprite.Position = { x: x, y: y };
            this.sprite.scale = initialScale;
            this.destScale = destScale;
            this.speed = speed;
            this.sprite.playAnimation('run', { repeat: Infinity });
        }
    }, {
        key: 'hit',
        value: function hit(onDie) {
            var _this8 = this;

            var speed = this.speed;
            this.speed = 0;
            this.sprite.playAnimation('hit').then(function () {
                _this8.speed = speed;

                if (--_this8.life <= 0) {
                    _this8.die();
                    onDie && onDie();
                } else {
                    _this8.sprite.playAnimation('run', { repeat: Infinity });
                }
            });
        }
    }, {
        key: 'die',
        value: function die() {
            var _this9 = this;

            this.speed = 0;
            this.attackTimer && this.attackTimer.stop();
            this.sprite.playAnimation('die', { after: 1000 }).then(function () {
                _this9.destroy();
            });
        }
    }, {
        key: 'attack',
        value: function attack(callback, speed, damage) {
            this.attackCallback = callback;
            this.attackSpeed = speed;
            this.attackDamage = damage;
        }
    }, {
        key: '_attack',
        value: function _attack() {
            var _this10 = this;

            var sprite = this.sprite;
            if (!this.attackTimer) {
                this.attackTimer = new Interval(function () {
                    sprite.playAnimation('attack').then(function () {
                        sprite.playAnimation('idle', { repeat: Infinity });
                        _this10.attackCallback(_this10.attackDamage);
                    });
                }, this.attackSpeed, Infinity, true);
            }
        }
    }, {
        key: 'render',
        value: function render(ctx, elapse, interval) {

            this.sprite.scale += interval * this.speed / 1000;

            //ctx.fillText(this.sprite.Position.x,this.sprite.Position.y,this.z)
            if (this.sprite.curAnimation.name == 'run') {
                this.sprite.Position.y += 2.5 * this.speed;
            }
            if (this.sprite.scale >= this.destScale && this.sprite.curAnimation.name == 'run') {
                this.speed = 0;

                this._attack();
            }
            this.sprite.render(ctx, elapse, interval);
            this.z = this.sprite.bottom;
        }
    }]);

    return Enemy;
}(GameObject);

var Layer = function () {
    function Layer(w, h, x, y) {
        var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'canvas';

        _classCallCheck(this, Layer);

        this.layerElement = document.createElement(type);

        if (type == 'canvas') {
            this.layerElement.width = w;
            this.layerElement.height = h;
        } else {
            this.layerElement.style.width = w + 'px';
            this.layerElement.style.height = h + 'px';
        }
        this.layerElement.style.position = 'absolute';
        this.layerElement.style.left = x + 'px';
        this.layerElement.style.top = y + 'px';
        document.body.appendChild(this.layerElement);
        this.index = Layer._index++;
        Layer._map[this.index] = this;
    }

    _createClass(Layer, [{
        key: 'Name',
        value: function Name(name) {
            this.name = name;
            Layer._map[name] = this;
            delete Layer._map[this.index];
        }
    }]);

    return Layer;
}();

Layer._map = {};
Layer._index = 0;

var Game = function () {
    function Game(ctx) {
        _classCallCheck(this, Game);

        this.layerStack = [];
        this.ctx = ctx;
        this._stop = false;
    }

    _createClass(Game, [{
        key: 'stop',
        value: function stop() {
            this._stop = true;
        }
    }, {
        key: 'pause',
        value: function pause() {
            this._stop = true;
        }
    }, {
        key: 'resume',
        value: function resume() {
            if (this._stop) {
                this._stop = false;
                requestAnimationFrame(this.step.bind(this));
            }
        }
    }, {
        key: 'createLayer',
        value: function createLayer() {
            var w = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.innerWidth;
            var h = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.innerHeight;
            var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
            var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

            var layer = document.createElement('canvas');
            layer.width = w;
            layer.height = h;
            if (this.layerStack.length > 0) {
                layer.style.position = 'absolute';
                layer.style.left = x + 'px';
                layer.style.top = y + 'px';
            }
            document.body.appendChild(layer);
        }
    }, {
        key: 'init',
        value: function init(progress) {
            Sprite.onProgress = progress;
            this.initPromise = Sprite.init();
            return this;
        }
    }, {
        key: 'start',
        value: function start(callback) {
            var _this11 = this;

            var ctx = this.ctx;
            this.initPromise.then(function () {
                var startTime = 0;

                _this11.step = function (elapse) {
                    var interval = elapse - startTime;
                    startTime = elapse;
                    if (interval > 1000) {
                        interval = 16.7;
                    }
                    ctx.clearRect(0, 0, cvs.width, cvs.height);
                    glGameObjectList.sort(function (a, b) {
                        return a.z - b.z;
                    }).forEach(function (go) {
                        go.render(ctx, elapse, interval);
                    });
                    glIntervalList.forEach(function (itv) {
                        itv.testOrRun(elapse, interval);
                    });
                    if (!this._stop) requestAnimationFrame(this.step.bind(this));
                };

                requestAnimationFrame(_this11.step.bind(_this11));
                callback();
            });
            return this;
        }
    }]);

    return Game;
}();

var ResourceTypes = [{ regexp: '/png|gif|jpe?g/', type: 'image' }];
