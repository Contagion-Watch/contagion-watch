/**
 * Created by exolution on 17/6/7.
 */
Promise.defer = function () {
    let _defer = {}
    let promise = new Promise(function (resolve, reject) {
        _defer.resolve = resolve
        _defer.reject = reject
    })
    promise.resolve = _defer.resolve
    promise.reject = _defer.reject
    return promise
}
class Sprite {

    constructor(imgSrc, column, row, width, height) {
        this.imgSrc = imgSrc
        this.imgWidth = width
        this.imgHeight = height
        this.row = row
        this.scale = 1
        this.column = column
        this.animation = {}
        this.rect = false
        this.area = {}
        this.Position = {
            x: 0, y: 0
        }
        Sprite.spritesList.push(this)
    }

    createArea(name, config) {
        this.area[name] = config
    }

    static init() {
        Sprite.complete=0
        return Promise.all(Sprite.spritesList.map(sprites=>sprites.init()))
    }

    init() {
        return new Promise((resolve, reject)=> {
            this.image = new Image()
            this.image.src = this.imgSrc
            this.image.onload = ()=> {
                this.imgWidth = this.imgWidth || this.image.width
                this.imgHeight = this.imgHeight || this.image.height
                if(Sprite.onProgress){
                    Sprite.onProgress(++Sprite.complete,Sprite.spritesList.length)
                }
                resolve()
            }
        })

    }

    playAnimation(name, {delay,after,repeat}={}, callback) {
        this.curAnimation = {
            promise: Promise.defer(),
            indexs: this.animation[name].indexs,
            curIndex: 0,
            elapse: 0,
            after,
            curAfter: after || 0,
            delay,
            repeat,
            callback,
            count: 0,
            state: 'START',
            name,
            fps: this.animation[name].indexs.length / this.animation[name].duration
        }
        return this.curAnimation.promise


    }

    getArea(name, frmIdx) {
        let def = this.area[name], area
        frmIdx = this.curAnimation.indexs[this.curAnimation.curIndex]
        for (let key in def) {
            let splits = key.split('-')
            if ((frmIdx >= +splits[0] && frmIdx <= +splits[1])) {
                area = def[key]

            }
            else if (+splits[0] == frmIdx) {
                area = def[key]
                break;
            }
        }
        if (!area) area = this.area['*']
        if (area) {
            return [
                this.Position.x - (this.imgWidth / this.column / 2 - area[0]) * this.scale,
                this.Position.y - (this.imgHeight / this.row / 2 - area[1]) * this.scale,
                area[2] * this.scale,
                area[3] * this.scale
            ]

        }
        return null
    }

    draw(animation, ctx) {
        let pos = animation.indexs[animation.curIndex]
        let width = this.imgWidth / this.column
        let height = this.imgHeight / this.row
        let targetX = this.Position.x - width / 2 * this.scale
        let targetY = this.Position.y - height / 2 * this.scale
        this.bottom=this.Position.y - height / 2 * this.scale+height * this.scale
        ctx.drawImage(this.image,
            pos % this.column * width,
            Math.floor(pos / this.column) * height,
            width,
            height,
            targetX,
            targetY,
            width * this.scale,
            height * this.scale
        )
        if (this.rect) {
            ctx.beginPath()
            ctx.strokeStyle="#fff"
            ctx.rect(this.Position.x - width / 2 * this.scale,
                this.Position.y - height / 2 * this.scale,
                width * this.scale,
                height * this.scale)
            for (let key in this.area) {
                let area = this.getArea(key, pos)
                if (area) {
                    ctx.rect(area[0], area[1], area[2], area[3])
                    ctx.font='30px serif'
                    ctx.fillText(pos+key,area[0]+2, area[1]+2)
                }
            }
            ctx.stroke()
            ctx.closePath()
        }
    }

    createAnimation(name, indexs, duration) {
        if (typeof indexs === 'string') {
            indexs = genArray(indexs)
        }
        this.animation[name] = {indexs, duration}
    }

    stopAnimation(name, immidiate) {
        if (immidiate) {
            this.curAnimation = null
        }
        else {
            this.curAnimation.repeat = false
        }
    }

    render(ctx, elapse, interval) {

        if (this.curAnimation) {

            this.curAnimation.elapse += interval
            this.draw(this.curAnimation, ctx)
            if (this.curAnimation.elapse * this.curAnimation.fps > 1) {
                if (this.curAnimation.curIndex + 1 == this.curAnimation.indexs.length) {

                    if (this.curAnimation.curAfter <= 0) {
                        if (--this.curAnimation.repeat > 0) {
                            this.curAnimation.state = 'START'
                            this.curAnimation.curAfter = this.curAnimation.after || 0
                            this.curAnimation.curIndex = 0
                            this.curAnimation.callback && this.curAnimation.callback(this.curAnimation.count++)
                        }
                        else {
                            this.curAnimation.state = 'END'
                            this.curAnimation.promise.resolve()
                            this.curAnimation = null
                            return
                        }
                    }
                    else {
                        this.curAnimation.state = 'AFTER'
                    }

                }
                else {
                    this.curAnimation.curIndex++
                }

                this.curAnimation.elapse = this.curAnimation.elapse % (1 / this.curAnimation.fps )
            }
            if (this.curAnimation.state == 'AFTER') {
                this.curAnimation.curAfter -= interval
            }

        }

    }
}
function genArray(fromTo) {
    let splits = fromTo.split('-')
    let arr = []
    for (let i = +splits[0]; i <= +splits[1]; i++) {
        arr.push(i)
    }
    return arr
}
Sprite.spritesList = []
const glIntervalList = []
class Interval {
    constructor(callback, interval, repeat, immidiate) {
        this.callback = callback
        this.interval = interval
        this.repeat = repeat
        this.immidiate = immidiate
        this.elapse = 0
        glIntervalList.push(this)
        this._pause = false
        if (typeof repeat === 'boolean') {
            this.immidiate = repeat
            this.repeat = undefined
        }
        if (this.immidiate) {
            this.callback()
        }
    }

    pause() {
        this._pause = true
    }

    resume() {
        this._pause = false
    }

    testOrRun(elapse, interval) {
        if(!this._pause) {
            this.elapse += interval
            if (this.elapse > this.interval) {
                this.callback()
                this.elapse = this.elapse & interval
                if (!this.repeat && --this.repeat <= 0) {
                    this.stop()
                }
            }
        }
    }

    stop() {
        for (let i = 0; i < glIntervalList.length; i++) {
            if (glIntervalList[i] === this) {
                glIntervalList.splice(i, 1)
                break;
            }
        }
    }
}
const glGameObjectList = []
class GameObject {
    constructor(tag) {
        this.tag = tag
        glGameObjectList.push(this)
    }

    destroy() {
        for (let i = 0; i < glGameObjectList.length; i++) {
            if (glGameObjectList[i] === this) {
                glGameObjectList.splice(i, 1)
                break;
            }
        }
    }

    render(ctx, elapse, interval) {
        if (this.sprite) {
            this.sprite.render(ctx, elapse, interval)
        }
    }

    setInterval(callback, interval, once) {

    }

    clearInterval(intervalId) {

    }
}
class Cursor extends GameObject {
    constructor() {
        super('cursor')
        this.z = Infinity
    }

    render(ctx, elapse, interval) {
        ctx.beginPath()
        //ctx.fillStyle="#d3d14d"
        ctx.fillStyle = 'rgba(211, 209, 0,0.8)'
        let len = 30, w = 6, dist = 8
        ctx.fillRect(this.x - (w - 1) / 2, this.y - (w - 1) / 2, w, w)
        ctx.fillRect(this.x - len - (w - 1) / 2 - dist, this.y - (w - 1) / 2, len, w)
        ctx.fillRect(this.x + dist + (w - 1) / 2, this.y - (w - 1) / 2, len, w)
        ctx.fillRect(this.x - (w - 1) / 2, this.y - (w - 1) / 2 - dist - len, w, len)
        ctx.fillRect(this.x - (w - 1) / 2, this.y + (w - 1) / 2 + dist, w, len)
        ctx.closePath()
        ctx.stroke()
    }
}
class Actor extends GameObject {
    constructor() {
        super('actor')
        this.z = Infinity


    }

    init(hp,maxShell,scale) {
        this.hp=hp
        this.maxShell=maxShell
        this.shell=maxShell
        this.sprite.playAnimation('idle', {repeat: Infinity})
        this.sprite.scale = scale;
        this.sprite.Position = {x: 160 * scale, y: cvs.height - 160 * scale}
        this.kills=0
    }
    stopAttack(){
        this._attacking=false
    }
    attack(targetPos, callback) {
        if(!this.sprite.curAnimation||this.sprite.curAnimation.name!=='change') {
            this._attacking = true
            let aniName
            this.targetPos = targetPos
            if (targetPos.x / (cvs.width) < 1 / 3) {
                aniName = 'left'
            }
            else if (targetPos.x / (cvs.width) < 2 / 3) {
                aniName = 'middle'
            }
            else {
                aniName = 'right'
            }
            this.shell--
            this.onShellChange&&this.onShellChange()
            cvs.style.animation="shake ease 0.32s infinite";
            this.sprite.playAnimation(aniName, {repeat: 2}).then(()=> {
                cvs.style.animation=''
                if (this.shell > 0) {
                    if (this._attacking) {
                        this.attack(this.targetPos, callback)
                    }
                    else {
                        this.sprite.playAnimation('idle', {repeat: Infinity})
                    }
                }
                else {
                    this.sprite.playAnimation('change').then(()=> {
                        this.shell=this.maxShell
                        this.onShellChange&&this.onShellChange()
                        if(this._attacking){
                            this.attack(this.targetPos, callback)
                        }
                        else{
                            this.sprite.playAnimation('idle', {repeat: Infinity})
                        }
                    })
                }
            })
            let ret=glGameObjectList.filter(go=>go.tag == 'enemy').sort((a, b)=>b.sprite.scale - a.sprite.scale).some(go=> {
                let head = go.sprite.getArea('head')
                if (head && isPointInArea(targetPos.x, targetPos.y, head)) {
                    callback.call(this, 'head', go)
                    return true
                }
                else {
                    let shield=go.sprite.getArea('shield')
                    if (shield && isPointInArea(targetPos.x, targetPos.y, shield)) {
                        callback.call(this, 'shield', go)
                        return true
                    }
                    let body = go.sprite.getArea('body')
                    if (body && isPointInArea(targetPos.x, targetPos.y, body)) {
                        callback.call(this, 'body', go)
                        return true
                    }


                }

            })
            if(!ret){
                callback()
            }
        }
    }

    render(ctx, elapse, interval) {
        this.sprite.render(ctx, elapse, interval)
    }

}
function isPointInArea(x, y, area) {
    return x > area[0] && y > area[1] && x < area[0] + area[2] && y < area[1] + area[3]
}
class Effect extends GameObject {
    constructor(sprite, pos,scale) {
        super('effect')

        this.sprite = {}
        Object.setPrototypeOf(this.sprite, sprite)
        this.sprite.Position = pos
        this.sprite.scale=scale||1
        this.z=Infinity
        this.sprite.playAnimation('effect').then(()=> {
            this.destroy()
        })
    }
}
class Text extends GameObject{
    constructor(text,x,y,speed,duration){
        super('text')
        this.z=Infinity
        this.text=text
        this.x=x
        this.y=y
        this.elapse=0
        this.speed=speed
        this.duration=duration
    }
    render(ctx,elapse,interval){

        ctx.font = '48px serif';
        ctx.fillText(this.text,this.x,this.y)
        this.elapse+=interval
        if(this.elapse<this.duration){
            this.y-=interval*this.speed
        }
        else{
            this.destroy()
        }

    }
}
class Enemy extends GameObject {
    constructor() {
        super('enemy')
        this.z = 1
        this.life = 2
    }

    setSprite(sprite) {
        this.sprite = {}
        Object.setPrototypeOf(this.sprite, sprite)
    }

    init(initialScale, destScale, speed, x, y) {
        this.sprite.Position = {x, y}
        this.sprite.scale = initialScale
        this.destScale = destScale
        this.speed = speed
        this.sprite.playAnimation('run', {repeat: Infinity})
    }

    hit(onDie) {
        let speed = this.speed
        this.speed = 0
        this.sprite.playAnimation('hit').then(()=> {
            this.speed = speed

            if (--this.life <= 0) {
                this.die()
                onDie&&onDie()
            }
            else {
                this.sprite.playAnimation('run', {repeat: Infinity})
            }
        })
    }

    die() {
        this.speed = 0
        this.attackTimer && this.attackTimer.stop()
        this.sprite.playAnimation('die', {after: 1000}).then(()=> {
            this.destroy()
        })
    }
    attack(callback,speed,damage){
        this.attackCallback=callback
        this.attackSpeed=speed
        this.attackDamage=damage
    }
    _attack() {
        let sprite = this.sprite
        if(!this.attackTimer) {
            this.attackTimer = new Interval( ()=> {
                sprite.playAnimation('attack').then( ()=> {
                    sprite.playAnimation('idle', {repeat: Infinity})
                    this.attackCallback(this.attackDamage)
                })
            }, this.attackSpeed, Infinity, true)
        }

    }

    render(ctx, elapse, interval) {

        this.sprite.scale += interval * this.speed / 1000

        //ctx.fillText(this.sprite.Position.x,this.sprite.Position.y,this.z)
        if (this.sprite.curAnimation.name == 'run') {
            this.sprite.Position.y += 2.5*this.speed
        }
        if (this.sprite.scale >= this.destScale && this.sprite.curAnimation.name == 'run') {
            this.speed = 0

            this._attack()
        }
        this.sprite.render(ctx, elapse, interval)
        this.z=this.sprite.bottom
    }
}
class Layer {

    constructor(w, h, x, y, type = 'canvas') {
        this.layerElement = document.createElement(type);

        if (type == 'canvas') {
            this.layerElement.width = w;
            this.layerElement.height = h;
        }
        else {
            this.layerElement.style.width = w + 'px';
            this.layerElement.style.height = h + 'px';
        }
        this.layerElement.style.position = 'absolute'
        this.layerElement.style.left = x + 'px'
        this.layerElement.style.top = y + 'px'
        document.body.appendChild(this.layerElement)
        this.index = Layer._index++
        Layer._map[this.index] = this
    }

    Name(name) {
        this.name = name
        Layer._map[name] = this
        delete Layer._map[this.index]
    }
}
Layer._map = {}
Layer._index = 0

class Game {
    constructor(ctx) {
        this.layerStack = []
        this.ctx=ctx
        this._stop=false
    }
    stop(){
        this._stop=true
    }
    pause(){
        this._stop=true
    }
    resume(){
        if(this._stop) {
            this._stop = false
            requestAnimationFrame(this.step.bind(this))
        }
    }
    createLayer(w = window.innerWidth, h = window.innerHeight, x = 0, y = 0) {
        let layer = document.createElement('canvas');
        layer.width = w;
        layer.height = h;
        if (this.layerStack.length > 0) {
            layer.style.position = 'absolute'
            layer.style.left = x + 'px'
            layer.style.top = y + 'px'
        }
        document.body.appendChild(layer)
    }
    init(progress){
        Sprite.onProgress=progress
        this.initPromise=Sprite.init()
        return this
    }
    start(callback) {
        let ctx=this.ctx
        this.initPromise.then(()=>{
            let startTime = 0;

            this.step=function (elapse) {
                let interval = elapse - startTime
                startTime = elapse
                if (interval > 1000) {
                    interval = 16.7
                }
                ctx.clearRect(0, 0, cvs.width, cvs.height)
                glGameObjectList.sort((a, b)=>a.z - b.z).forEach(function (go) {
                    go.render(ctx, elapse, interval)
                })
                glIntervalList.forEach(function (itv) {
                    itv.testOrRun(elapse, interval)
                })
                if(!this._stop)requestAnimationFrame(this.step.bind(this))
            }

            requestAnimationFrame(this.step.bind(this))
            callback()
        })
    return this
    }
}

    const ResourceTypes=[
    {regexp:'/png|gif|jpe?g/',type:'image'}
]
