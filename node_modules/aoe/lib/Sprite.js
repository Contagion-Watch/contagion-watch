'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by exolution on 17/6/14.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _Vector = require('./Vector');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Sprite = function () {
    function Sprite(resource, column, row, width, height) {
        _classCallCheck(this, Sprite);

        this.resource = resource;
        this.imgSrc = imgSrc;
        this.imgWidth = width;
        this.imgHeight = height;
        this.row = row;
        this.scale = 1;
        this.column = column;
        this.animation = {};
        this.rect = false;
        this.area = {};
        this.Position = new _Vector.Vector3();
    }

    _createClass(Sprite, [{
        key: 'createArea',
        value: function createArea(name, config) {
            this.area[name] = config;
        }
    }, {
        key: 'playAnimation',
        value: function playAnimation(name) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                delay = _ref.delay,
                after = _ref.after,
                repeat = _ref.repeat;

            var callback = arguments[2];

            this.curAnimation = {
                promise: Promise.defer(),
                indexs: this.animation[name].indexs,
                curIndex: 0,
                elapse: 0,
                after: after,
                curAfter: after || 0,
                delay: delay,
                repeat: repeat,
                callback: callback,
                count: 0,
                state: 'START',
                name: name,
                fps: this.animation[name].indexs.length / this.animation[name].duration
            };
            return this.curAnimation.promise;
        }
    }, {
        key: 'getArea',
        value: function getArea(name, frmIdx) {
            var def = this.area[name],
                area = void 0;
            frmIdx = this.curAnimation.indexs[this.curAnimation.curIndex];
            for (var key in def) {
                var splits = key.split('-');
                if (frmIdx >= +splits[0] && frmIdx <= +splits[1]) {
                    area = def[key];
                } else if (+splits[0] == frmIdx) {
                    area = def[key];
                    break;
                }
            }
            return area || this.area['*'];
        }
    }, {
        key: 'draw',
        value: function draw(animation, ctx, position, scale) {
            var pos = animation.indexs[animation.curIndex];
            var width = this.resource.width / this.column;
            var height = this.resource.height / this.row;
            var targetX = position.x - width / ctx.dpr * scale;
            var targetY = position.y - height / ctx.dpr * scale;
            //this.bottom=this.Position.y - height / 2 * scale+height * this.scale
            ctx.drawImage(this.image, pos % this.column * width, Math.floor(pos / this.column) * height, width, height, targetX, targetY, width * this.scale, height * this.scale);
            if (this.rect) {
                ctx.beginPath();
                ctx.strokeStyle = "#fff";
                ctx.rect(this.Position.x - width / 2 * this.scale, this.Position.y - height / 2 * this.scale, width * this.scale, height * this.scale);
                for (var key in this.area) {
                    var area = this.getArea(key, pos);
                    if (area) {
                        ctx.rect(area[0], area[1], area[2], area[3]);
                        ctx.font = '30px serif';
                        ctx.fillText(pos + key, area[0] + 2, area[1] + 2);
                    }
                }
                ctx.stroke();
                ctx.closePath();
            }
        }
    }, {
        key: 'createAnimation',
        value: function createAnimation(name, indexs, duration) {
            if (typeof indexs === 'string') {
                indexs = genArray(indexs);
            }
            this.animation[name] = { indexs: indexs, duration: duration };
        }
    }, {
        key: 'stopAnimation',
        value: function stopAnimation(name, immidiate) {
            if (immidiate) {
                this.curAnimation = null;
            } else {
                this.curAnimation.repeat = false;
            }
        }
    }, {
        key: 'render',
        value: function render(ctx, elapse, interval) {

            if (this.curAnimation) {

                this.curAnimation.elapse += interval;
                this.draw(this.curAnimation, ctx);
                if (this.curAnimation.elapse * this.curAnimation.fps > 1) {
                    if (this.curAnimation.curIndex + 1 == this.curAnimation.indexs.length) {

                        if (this.curAnimation.curAfter <= 0) {
                            if (--this.curAnimation.repeat > 0) {
                                this.curAnimation.state = 'START';
                                this.curAnimation.curAfter = this.curAnimation.after || 0;
                                this.curAnimation.curIndex = 0;
                                this.curAnimation.callback && this.curAnimation.callback(this.curAnimation.count++);
                            } else {
                                this.curAnimation.state = 'END';
                                this.curAnimation.promise.resolve();
                                this.curAnimation = null;
                                return;
                            }
                        } else {
                            this.curAnimation.state = 'AFTER';
                        }
                    } else {
                        this.curAnimation.curIndex++;
                    }

                    this.curAnimation.elapse = this.curAnimation.elapse % (1 / this.curAnimation.fps);
                }
                if (this.curAnimation.state == 'AFTER') {
                    this.curAnimation.curAfter -= interval;
                }
            }
        }
    }]);

    return Sprite;
}();

exports.default = Sprite;

function genArray(fromTo) {
    var splits = fromTo.split('-');
    var arr = [];
    for (var i = +splits[0]; i <= +splits[1]; i++) {
        arr.push(i);
    }
    return arr;
}