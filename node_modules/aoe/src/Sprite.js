/**
 * Created by exolution on 17/6/14.
 */
import {Vector3} from './Vector'
export default class Sprite {

    constructor(resource, column, row, width, height) {
        this.resource=resource
        this.imgSrc = imgSrc
        this.imgWidth = width
        this.imgHeight = height
        this.row = row
        this.scale = 1
        this.column = column
        this.animation = {}
        this.rect = false
        this.area = {}
        this.Position = new Vector3()

    }

    createArea(name, config) {
        this.area[name] = config
    }



    playAnimation(name, {delay,after,repeat}={}, callback) {
        this.curAnimation = {
            promise: Promise.defer(),
            indexs: this.animation[name].indexs,
            curIndex: 0,
            elapse: 0,
            after,
            curAfter: after || 0,
            delay,
            repeat,
            callback,
            count: 0,
            state: 'START',
            name,
            fps: this.animation[name].indexs.length / this.animation[name].duration
        }
        return this.curAnimation.promise


    }

    getArea(name, frmIdx) {
        let def = this.area[name], area
        frmIdx = this.curAnimation.indexs[this.curAnimation.curIndex]
        for (let key in def) {
            let splits = key.split('-')
            if ((frmIdx >= +splits[0] && frmIdx <= +splits[1])) {
                area = def[key]

            }
            else if (+splits[0] == frmIdx) {
                area = def[key]
                break;
            }
        }
        return area||this.area['*']
    }

    draw(animation, ctx,position,scale) {
        let pos = animation.indexs[animation.curIndex]
        let width = this.resource.width / this.column
        let height = this.resource.height / this.row
        let targetX = position.x - width / ctx.dpr * scale
        let targetY = position.y - height / ctx.dpr * scale
        //this.bottom=this.Position.y - height / 2 * scale+height * this.scale
        ctx.drawImage(this.image,
            pos % this.column * width,
            Math.floor(pos / this.column) * height,
            width,
            height,
            targetX,
            targetY,
            width * this.scale,
            height * this.scale
        )
        if (this.rect) {
            ctx.beginPath()
            ctx.strokeStyle="#fff"
            ctx.rect(this.Position.x - width / 2 * this.scale,
                this.Position.y - height / 2 * this.scale,
                width * this.scale,
                height * this.scale)
            for (let key in this.area) {
                let area = this.getArea(key, pos)
                if (area) {
                    ctx.rect(area[0], area[1], area[2], area[3])
                    ctx.font='30px serif'
                    ctx.fillText(pos+key,area[0]+2, area[1]+2)
                }
            }
            ctx.stroke()
            ctx.closePath()
        }
    }

    createAnimation(name, indexs, duration) {
        if (typeof indexs === 'string') {
            indexs = genArray(indexs)
        }
        this.animation[name] = {indexs, duration}
    }

    stopAnimation(name, immidiate) {
        if (immidiate) {
            this.curAnimation = null
        }
        else {
            this.curAnimation.repeat = false
        }
    }

    render(ctx, elapse, interval) {

        if (this.curAnimation) {

            this.curAnimation.elapse += interval
            this.draw(this.curAnimation, ctx)
            if (this.curAnimation.elapse * this.curAnimation.fps > 1) {
                if (this.curAnimation.curIndex + 1 == this.curAnimation.indexs.length) {

                    if (this.curAnimation.curAfter <= 0) {
                        if (--this.curAnimation.repeat > 0) {
                            this.curAnimation.state = 'START'
                            this.curAnimation.curAfter = this.curAnimation.after || 0
                            this.curAnimation.curIndex = 0
                            this.curAnimation.callback && this.curAnimation.callback(this.curAnimation.count++)
                        }
                        else {
                            this.curAnimation.state = 'END'
                            this.curAnimation.promise.resolve()
                            this.curAnimation = null
                            return
                        }
                    }
                    else {
                        this.curAnimation.state = 'AFTER'
                    }

                }
                else {
                    this.curAnimation.curIndex++
                }

                this.curAnimation.elapse = this.curAnimation.elapse % (1 / this.curAnimation.fps )
            }
            if (this.curAnimation.state == 'AFTER') {
                this.curAnimation.curAfter -= interval
            }

        }

    }
}
function genArray(fromTo) {
    let splits = fromTo.split('-')
    let arr = []
    for (let i = +splits[0]; i <= +splits[1]; i++) {
        arr.push(i)
    }
    return arr
}